= How blockchain works
Chris Braithwaite <christopher.braithwaite@lightcurve.io> Mona Bärenfänger <mona@lightcurve.io>
:description: The How blockchain works page describes in more detail the functionalities of a blockchain.
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images

:page-previous: /root/intro/what-is-blockchain.html
:page-previous-title: What is blockchain
:page-next: /root/intro/lisk-products.html
:page-next-title: Lisk products

:url_p2p_architecture: {sdk-docs}references/lisk-elements/p2p.adoc#architecture
:url_state_store: understand-blockchain/modules-assets.adoc#the-state-store
:url_blockchain: /root/intro/what-is-blockchain.adoc
:url_pos: https://www.investopedia.com/terms/p/proof-stake-pos.asp
:url_p2p_networks: https://www.blockchain-council.org/blockchain/blockchain-role-of-p2p-network/
:url_hashing: https://www.onlinehashcrack.com/how-to-hashing-in-blockchain-explained.php
:url_account-store: {sdk-docs}references/lisk-elements/chain.adoc#state-store-and-database-mechanism
:url_voting-mechanism: https://blockchain-academy.hs-mittweida.de/courses/blockchain-introduction-technical-beginner-to-intermediate/lessons/lesson-20-introduction-and-basic-functionality-of-delegated-proof-of-stake/topic/voting-in-dpos/
:url_lisk-products: /root/intro/lisk-products.adoc

== Overview

As described on the previous xref:{url_blockchain}[What is blockchain] page, from a high-level perspective a blockchain a 'digital ledger' which has many functionalities and use cases.
It can also be thought of as a digital methodology to store data, whereby the data is encapsulated in blocks, and once the blocks are chained together they cannot be changed or altered, thus making them immutable.
Once a block of data is added to the blockchain it will remain publicly viewable to anyone at any time.
This is a highly beneficial system as it enables permanent records to be kept, enabling the storage of almost any type of record.
For example, it could be virtually anything such as medical records, financial transactions, property rights, etc.

To start to break down how the blockchain works, and before we delve into the detailed contents of a block, firstly we need to understand how the blocks are linked together, this is accomplished by using cryptography.
Therefore, each block contains a cryptographic hash of the previous block, the transaction data,  and a timestamp.
This will be explained in more detail further in this section.
As previously mentioned once created, the blocks are immutable and cannot be changed retroactively.
The only way this could be achieved would be by altering the subsequential blocks, which would require the consensus of the entire network.

== Key characteristics of blockchain

There are 4 core characteristics attributed to the blockchain which are covered below:

* Decentralization – The contents of each block in the blockchain can be accessed by any node on the network, as they are essentially network copies that are present on all participating nodes.
Therefore, there is no central entity that holds each block in the chain, so this creates decentralization.

* Consensus Driven – A consensus model independently verifies each block on the blockchain, and provides certain rules for validating a block, which may utilize key resources such as computing power, in order to demonstrate that this has been accomplished.
For example, with regard to Bitcoin, this is known as the mining process.
There are different types of consensus models which will be covered further in this section, however, suffice to say that a consensus model is able to function independently, and does not require any form of central authority.

* Immutability – A blockchain can be considered a permanent, unchangeable, and irreversible record of transactions.
Hence, once a block is created and added to the blockchain it ensures the transaction is completely trustable.

* Transparency – A blockchain by its very nature provides total open transparency.
A full transaction history can be viewed by any party, as it is in effect an open file.
Therefore another highly beneficial advantage is that a blockchain creates provenance, as all transactions can be easily audited from the first to the last entry.

== Consensus mechanisms

It is important to understand consensus within the blockchain ecosystem.
Basically, a consensus mechanism is a methodology deployed by nodes to agree on, and validate the data content of a block before it becomes part of a blockchain.
The block containing this data is then distributed to all the nodes within the network.
The consensus algorithm is responsible for ensuring that only 1 copy of the data encapsulated in each block exists within each node.
To put it in a nutshell, a consensus mechanism can be thought of as a necessary procedure that results in ensuring all peers of a blockchain network come to a common agreement on the current state of the network.

Various consensus mechanisms exist today, however, the 4 main mechanisms that are widely used consist of the *Proof-of-Work*, *Proof-of-Stake*, *Delegated-Proof-of-Stake*, and *Byzantine-Fault-Tolerance* mechanisms, which are explained below:

=== Proof-of-Work (PoW)

Proof of Work is probably the most well-known and established consensus mechanism, as it is utilized by Bitcoin.
However, when compared to the other consensus mechanisms, it is somewhat inefficient as it requires a high amount of energy and processing power which is often attributable to the degree of competition between the miners in order to reach a consensus, therefore this results in being rather cumbersome and expensive to operate.
Basically, to validate transactions it requires the nodes to solve an arbitrary mathematical problem or complex equations, which prevents the network from being hacked, and also provides a high level of security.
The term 'Proof of Work' stems from how the crypto minors effectively 'prove' that they have accomplished the necessary tasks in order to create a correctly formed block of transactions that will be added to the blockchain.
In essence, this can be thought of as a competition whereby the miners are attempting to outdo each other and solve the complex mathematical equations, which in turn then allows them to add the next block to the blockchain.
Hence, this results in the miners receiving a reward for this in the form of tokens or coins.

=== Proof-of-Stake (PoS)
To explain PoS briefly, it allows the users to stake an asset/token which in turn opens up the possibility to be chosen as a validator of a new block, which then allows transaction fees, or newly minted tokens to be collected from the block as a reward.
Staking is defined as a number of tokens/assets that are held by the node.
The proof-of-stake-mechanism uses an algorithm designed to select users that have the highest stakes as validators, this results in motivating the highest stakeholders to ensure a transaction is executed, as logic dictates that the users with the highest amount of tokens or coins have the most to lose, therefore it is in their interest to ensure the network continues to grow.
This is highly beneficial for consensus building and eliminates the need for complex mathematical calculations, hence reducing the overall computing power and energy required.
Alternatively, the nodes that hold the most tokens/assets have the power to validate the transactions, which in turn results in this node receiving a reward, usually in newly minted tokens.
Further more detailed information regarding PoS can be found xref:{url_pos}[here].

=== Delegated-Proof-of-Stake (DPoS)

DPoS works in a similar fashion to PoS, however, one of the key advantages is that it utilizes a delegation and voting mechanism, which in turn incentives the users to use their staked collateral to secure the network.
To allow this mechanism to be both efficient and effective at performing transaction validations, various different components of delegated proof of stake exist.
Ultimately, the DPoS is considered the most advantageous mechanism here, as it was designed to negate most of the limitations that exist with PoW and PoS.
This consensus algorithm used in DPoS utilizes a unique election system that is able to select nodes that can perform block verification.
In this system, generally delegates are voted in based on their reputation.
Each user who holds a minimum of one token/coin with the DPoS blockchain has the ability to vote specifically for the nodes that they want to perform the transaction validations.
*Delegated-Proof-of-Stake* is the consensus mechanism used by Lisk, and hence every Lisk token holder is able to vote for delegates, and dependent on these votes, certain delegates are allowed to add blocks to the blockchain in a specific order.
The delegates are actually normal Lisk accounts that have performed a delegate registration transaction.
The whole process can be considered as the most democratic method of voting, as it does not rest on the users that possess the highest amount of tokens, as just because a particular user has many tokens, that does not authorize this user to validate and confirm transactions.
All the users that maintain tokens in their accounts are able to select a group of delegates to perform this task.
Furthermore, with this stake-weighted xref:{url_voting-mechanism}[voting mechanism] DPoS has the advantage of being able to execute transactions and verifications much faster than PoS or PoW, as there are a limited number of validators.
Therefore with DPoS, consensus can be reached quickly also resulting in higher scalability.

== Byzantine-Fault-Tolerance (BFT)

The BFT mechanism was designed in a manner whereby it is able to tolerate failures in the network, coupled with being able to withstand malicious attacks and corrupted data.
In a nutshell, the BFT mechanism ensures that the same guaranteed data is received by every node present in the network.
In essence, it allows consensus to be reached regardless if some of the nodes fail.

Firstly, there are 3 key features whereby BFT is able to improve the blockchain, and they are listed below:

* Safety: If 2 conflicting blocks occur on the network, then assuming two-thirds of the active delegates adhere honestly to the protocol, then these 2 conflicting blocks will not be finalized on the blockchain.

* Accountability: In the case whereby the protocol is violated by the delegate, they will be held responsible for this.
The key requirements for BFT must be accomplished by the nodes within a blockchain network, therefore, it is imperative they are deterministic and must begin with the same state for practical BFT.

* Liveness: New blocks can still be finalized on the network, even in the case whereby one third of the active delegates are offline.

The process of being able to tolerate a number of Byzantine process failures or crashes, whilst ensuring the network continues to function is defined as Byzantine-fault-tolerant.
To achieve BFT consensus the following requirements must be met:

1. Termination: An output is decided by every non-faulty process.
2. Agreement: The same output is decided by every non-faulty process.
3. Validity: Every process starts with the same input.
4. Integrity: The consensus value and all non-faulty process decisions achieved in point 2 above, need to have been put forward by some non-faulty process.

== Peer-2-Peer networks

The usage of a peer-to-peer model in blockchain offers various benefits as compared to a standard client-server-based system.
By its very nature, a P2P decentralized system offers a high level of security and does not require any third-party intermediaries, and in addition, assets cannot be frozen or manipulated by any entity.
Furthermore, due to its decentralized nature, whereby a majority of nodes must achieve consensus before any new blocks can be added to the chain, this makes it almost impossible for any malicious actors to alter or manipulate the data added to the blockchain.

To summarise,  a xref:{url_p2p_networks}[P2P network architecture] offers numerous benefits as compared to a traditional client-server-based network and results in greater freedom, improved security, and enhanced decentralization.

=== Unstructured P2P networks

In an unstructured P2P network there is no organization, hence the nodes are able to communicate and connect randomly.
Such networks are more suited to social platforms, or any type of system which experiences high churn rates.
However, such networks require a high amount of processing power and may incur long delays.

=== Structured P2P networks

A structured network can be considered the opposite of an unstructured network and is organized in a manner whereby the nodes are able to utilize efficient search mechanisms.
This can be performed by the nodes using a hash function.
However, although they are considered to be more efficient, they can be considered somewhat centralized.

=== Hybrid P2P networks

The hybrid P2P networks are actually a combination of the client-server model and the peer-to-peer architecture.
This can offer the best of both worlds, and operate more efficiently as they generally contain an index/central server which can also connect and provide connections between the network nodes.

=== Unstructured partial mesh networks

Lisk uses what is known as an unstructured P2P network, whereby the nodes randomly connect to each other, and are all considered equal participants in the network.
This methodology is highly advantageous as with a partial mesh topology not all nodes are connected to each other, and are only connected to a subset of nodes present in the network.
This increases the robustness and scalability, coupled with increased security.
Lisk utilizes the unstructured partial network methodology, and the following link in the *Lisk Elements* section shows the xref:{p2p_architecture}[Lisk P2P architecture] in more detail.

== Cryptography

Cryptography is not a new concept and ultimately is used to ensure secure communication between 2 parties can be established over an unsecured connection.
This can be accomplished by using an encryption mechanism as depicted in the example diagram below, whereby a plain text document is sent as a ciphered version to the recipient.
The recipient can only decrypt the ciphered text if he or she holds the identical symmetrical encryption key.
Therefore, this can be transmitted over an unsecured medium, as regardless of any third party or malicious actors intercepting this, they would not be able to decrypt the text, rendering it useless to them.

To delve a bit further into cryptography in blockchain, it is helpful to be aware of the 3 types of cryptography deployed today.
These can be broken down into the following three types:

=== Symmetric Key
This is the simplest method, as 1 common key is used for both the encryption and decryption process.
In this case, it is necessary to ensure the transfer of the common key can be performed safely from the sender to the recipient.
It is also referred to as secret-key cryptography as shown in the illustration below.

image:intro/symmetric-encryption.png[]

=== Asymmetric Key
This type of encryption functions by using a pair of keys.
This comprises an encryption key, and a decryption key, and is more commonly known as a public key and a private (or secret), key.
Basically, the algorithm deployed for this method generates both a secret, key and a unique public key.
The secret key as its name implies, is kept secret, and the public key is openly shared.
Furthermore, the asymmetric encryption method has an additional element of security, although the symmetric method of encryption is faster, nevertheless, they are both very effective.
However, it is important to note that there are two methods of cryptography algorithms that are deployed within the blockchain, which are the asymmetric model described here, and the hashing function described in the following paragraph below.

As discussed, the encryption techniques play an important role here, as it is critical for a blockchain to use the most secure methodology, which ensures the key functions can be securely managed, such as transaction authentication, digital signatures, and identity management.
It is quite common with regard to the management of cryptocurrencies that with the asymmetric model of encryption, the public key is generally the actual address that 'contains' the tokens or coins, and is publicly viewable.
Subsequently, the secret key is used by the holder of the tokens or coins to access the address, and hence be able to authorize and then perform any actions required.

image:intro/asymmetric-encryption.png[]

=== Hash Functions
This function does not utilize any keys, as it takes the contents of the plain text and deploys a cipher, which is used to generate a hash value of a fixed length from the plain text.
Hence, it is virtually impossible for the contents of this plain text to be unraveled from the cipher text.
Therefore, xref:{url_hashing}[hashing] does not only provide the required security, as described earlier on the previous page, it is also deterministic and has the ability to provide immutability as well, which as we have learned is highly beneficial.

Lisk maintains a cryptography package that contains all the cryptographic functionalities required when interacting with the Lisk ecosystem and can be used on both the server and client-side.

== State machine

A State machine is considered to be a concept whereby the definition relates to a machine that can have multiple states, however only one state is possible at any one given time.
Hence, a state in this case, refers to the current state of the blockchain system and its transactions that are responsible for triggering state transitions.
With regard to a blockchain system, it can be deemed as a deterministic, replicated state machine.

image::intro/state-machine.png[]

The state transition refers to the changes that occur in the state machine after a specific event has occurred.
Therefore, it is best thought of as a temporary data structure that holds a temporary state while processing a block.
Furthermore, it maintains a temporary state that exists during the processing of a block, as it exposes an interface that enables and results in the finalization of the snapshots.
From a high-level perspective, the state store can be broken down into 3 separate states, namely the Accounts, the Chain, and the Consensus.

Firstly, the xref:{url_account-store}[account store] handles token transfers, keys, and registering delegates.
Secondly, the chain state store is responsible for the delegate vote weights, the block headers of the 3 previous rounds, the network identifier, the total fees burnt, and finally the rewards for the last block.
Thirdly, the consensus store contains the validator information and the finalized block height, including the BFT voting ledger, and furthermore, regarding the BFT, the consensus store holds the internal state.
Finally, this is explained in more depth in the xref:{state_store}[Modules and Assets] page covering the state store changes and execution logic.

Now we have covered how a blockchain functions, the next step is to look at the extensive range of user-friendly xref:{url_lisk-products}[Lisk products] that will enable us to create and manage our own blockchain applications.



