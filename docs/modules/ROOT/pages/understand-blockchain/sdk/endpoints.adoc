= RPC endpoints of a Lisk node
Mona Bärenfänger <mona@lightcurve.io> Muhammad Talha <muhammad.talha@lightcurve.io>
:description: Introduces the Lisk communication architecture, which is based on IPC Unix Sockets and WebSocket.
//Settings
:toc: preamble
:idprefix:
:idseparator: -
:imagesdir: ../../assets/images
:sdk_docs: lisk-sdk::
//External URLs
:url_npm_lisk_sdk: https://www.npmjs.com/package/lisk-sdk
:url_wiki_ipc: https://en.wikipedia.org/wiki/Inter-process_communication
:url_websocket: https://en.wikipedia.org/wiki/WebSocket
:url_wiki_http_protocol: https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol
:url_eda: https://en.wikipedia.org/wiki/Event-driven_architecture
// Project URLs
:url_advanced_architecture: understand-blockchain/sdk/architecture.adoc#application
:url_advanced_rpc: api/lisk-node-rpc.adoc
:url_guides_config_rpc: build-blockchain/configure-app.adoc#rpc
:url_intro_modules: understand-blockchain/sdk/modules-assets.adoc
:url_intro_modules_assets: understand-blockchain/sdk/modules-assets.adoc#assets
:url_intro_modules_lifecycle: understand-blockchain/sdk/modules-assets.adoc#lifecycle-hooks
:url_intro_modules_statestore: understand-blockchain/sdk/modules-assets.adoc#the-state-store
:url_intro_plugins: understand-blockchain/sdk/plugins.adoc
:url_intro_plugins_load: understand-blockchain/sdk/plugins.adoc#defining-the-plugin-logic
:url_references_elements_apiclient: {sdk_docs}references/lisk-elements/api-client.adoc
:url_references_elements_client: {sdk_docs}references/lisk-elements/client.adoc
:url_references_plugins_monitor: {sdk_docs}plugins/monitor-plugin.adoc
:url_advanced_rpc_endpoints: {url_advanced_rpc}#endpoints
:url_advanced_rpc_events: {url_advanced_rpc}#events
:url_guides_asset: build-blockchain/create-asset.adoc
:url_lisk_sdk: glossary.adoc#lisk-sdk
:url_RPC_System_API: {url_advanced_rpc}#system
:url_RPC_Events: {url_advanced_rpc}#events
:JSON_RPC_Specs: https://www.jsonrpc.org/specification
:url_module_endpoints: {sdk_docs}/modules/index.adoc

The open Lisk communication architecture is based on three different RPC (Remote-Procedure-Call) API modes: {url_wiki_ipc}[Inter-Process Communication (IPC)^], {url_websocket}[WebSocket (WS)^], and {url_wiki_http_protocol}[Hypertext Transfer Protocol (HTTP)^].
The xref:{url_advanced_architecture}[Application] can be configured to expose either an IPC, WS, or an HTTP API. These APIs can be used by internal components such as modules and plugins. External services such as other scripts in JS, a tool in Rust, or a Python daemon can also use these APIs.

TIP: For more information about the configuration of the RPC endpoints, check out the xref:{url_guides_config_rpc}[configuration guide].

image::intro/Communication-architecture-transparent - v1.png[,600 ,align="center"]

[[the-api-client]]
== The API client

The xref:{url_references_elements_apiclient}[] simplifies sending API requests to a blockchain application via IPC or WS.

It can be imported into any JS client application.

It provides an interface to *subscribe* to all events and to *invoke* endpoints of a blockchain application, its modules and plugins.


TIP: To conveniently communicate with a blockchain application, use the `apiClient` included in the xref:{url_references_elements_client}[@liskhq/lisk-client] and the {url_npm_lisk_sdk}[lisk-sdk^] packages.

[tabs]

=====
WS API client example::
+
--
[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');
let clientCache;
const nodeAPIURL = 'ws://localhost:8080/ws';

const getClient = async () => {
    if (!clientCache) {
        clientCache = await apiClient.createWSClient(nodeAPIURL);
    }
    return clientCache;
};

const blockId = 123;

getClient().then((client) => {
    client.invoke("chain_getBlockByID", {
        id: blockId
    }).then(res => {
        const decodedBlock = client.block.decode(res);
        console.log("Decoded block: ", decodedBlock);
        process.exit(0);
    });
});
----
--
IPC API client example::
+
--
[source,js]
----
const { apiClient } = require('@liskhq/lisk-client');
let clientCache;
const nodeAPIURL = 'ws://localhost:8080/ws';

const getClient = async () => {
    if (!clientCache) {
        clientCache = await apiClient.createIPCClient('~/.lisk/my-app');
    }
    return clientCache;
};

const blockId = 123;

getClient().then((client) => {
    client.invoke("chain_getBlockByID", {
        id: blockId
    }).then(res => {
        const decodedBlock = client.block.decode(res);
        console.log("Decoded block: ", decodedBlock);
        process.exit(0);
    });
});
----
--
HTTP cURL::
+
--
Apart from the WS and IPC method, Lisk endpoints also support HTTP requests and response mechanisms. With a {JSON_RPC_Specs}[JSON RPC 2.0] based format, any endpoint can be invoked using a cURL request. For example:

[source,json]
----
curl --location --request POST 'http://localhost:7887/rpc' \
--header 'Content-Type: application/json' \
--data-raw '{
    "jsonrpc": "2.0",
    "id": "1",
    "method": "chain_getBlockByHeight",
    "params": {
        "height": 2291
    }
}'
----
--
=====

// === HTTP
// Apart from the WS and IPC method, Lisk endpoints also support HTTP requests and response mechanisms. With a {JSON_RPC_Specs}[JSON RPC 2.0] based format, any endpoint can be invoked using a cURL request. For example:

// [source,json]
// ----
// curl --location --request POST 'http://localhost:7887/rpc' \
// --header 'Content-Type: application/json' \
// --data-raw '{
//     "jsonrpc": "2.0",
//     "id": "1",
//     "method": "chain_getBlockByHeight",
//     "params": {
//         "height": 2291
//     }
// }'
//----


=== IPC vs WS vs HTTP

The three modes of communication i.e. IPC, WS, and HTTP allow 
blockchain applications to communicate with Lisk nodes.

// As mentioned earlier, there are three methods available whereby a node can communicate via the API:

// * IPC
// * WS
// * HTTP

*IPC* in general is the preferred method for local connections:

    * It is slightly faster.
    * It supports synchronous data exchange.
    * It does not use the system ports, so it mitigates any risk of collision when the ports are already in use by another application.
    * It can invoke and subscribe to endpoints and events, respectively.

*WS* on the contrary should be used if the node API has to communicate with services on remote servers.

    * It is a bidirectional communication protocol that allows sending and receiving of data between a client and a server.
    * A WS connection is kept alive until terminated by either the client or the server.
    * A WS connection is usually necessary if real-time data acquisition is required.
    * A WS connection can also invoke and subscribe to endpoints and events, respectively.

*HTTP* is stateless, so it can only be used for fetching data from an endpoint.

    * HTTP requests establish a uni-directional connection to the server and close it once a response is received.
    * Since an event emits data in real time, a subscription can only work if the receiver's connection is persistent. This is not possible with an HTTP connection, hence it cannot be used to subscribe to events.



// == Channels

// All modules and plugins have access to a `channel` to communicate with the application via actions and events.

// === Channel for modules

// The channel in modules has only one purpose: it allows a module to publish events to the application which were defined in the <<events>> property of the module.

// The channel is accessible inside of a module under `this._channel`.
// It is used especially in the xref:{url_intro_modules_lifecycle}[lifecycle-hooks], to publish the events of the module.

// The following function is available for a `channel` inside a module:

// * `publish(eventName: string, data?: object)`: Publishes an event.

// An example how to use the channel to publish an event is shown below:

// [source,js]
// ----
// this._channel.publish('hello:newHello', {
//   sender: transaction._senderAddress.toString('hex'),
//   hello: helloAsset.helloString
// });
// ----

// The above code example will publish the event `hello:newHello` to the application, and attach an object which is containing the sender address and the hello message of the last sent xref:{url_guides_asset}[hello transaction].

// === Channel for plugins

// The channel is used inside of the xref:{url_intro_plugins_load}[load()] function of a plugin.

// The following functions are available for a `channel` inside a plugin:

// * `publish(eventName: string, data?: object)`: Publishes an event.
// * `subscribe(eventName: string, cb: EventCallback)`: Subscribes to an event.
// * `once(actionName: string, cb: EventCallback)`: Executes the callback only once, when receiving the event for the first time.
// * `invoke(actionName: string, params?: object)`: Invokes an action.

// [source,js]
// ----
// channel.subscribe('app:block:new', ({ data }) => {
//     const decodedBlock = this.codec.decodeBlock(data.block);
//     this._knownTimestamps.push(decodedBlock.header.timestamp);
//     channel.publish('myPlugin:timestamp', { timestamp: decodedBlock.header.timestamp });
// });
// ----

== Aliases

<<events>> and <<endpoints>> are identified by their aliases.

Example alias:

 "system_getNodeInfo"

An alias always consists of the following parts:

. *Prefix:* A *namespace* from which an event or an endpoint belongs to. The prefix `system` in this example is referring to the xref:{url_RPC_System_API}[System namespace].
. *Separator:*
The prefix and suffix are always separated by an underscore `_`.
. *Suffix:* A suffix is a name of the event or an endpoint e.g. `getNodeInfo` is the name of an endpoint that exists inside the `system` namespace.

== Interfaces

A blockchain application communicates via interfaces i.e. <<endpoints>> and <<events>>. Endpoints are invoked and events are subscribed to. Within an application, different interfaces are exposed to different components. This is summarized in the following diagram.

// A blockchain application communicates via <<endpoints>> and <<events>>, where endpoints are invoked and events are subscribed to via the available modes of communications.

// The different components of the application each have access to different parts of these interfaces.



image::intro/Sdk-interfaces.png[,600 ,align="center"]

For each endpoint and event displayed above, the following statements apply:

* ... `reply` means, the component can reply to this kind of RPC request.
* ... `invoke` means, the component can invoke this kind of RPC request.
// * ... `publish` means, the component can publish events.
* ... `subscribe` means, the component can subscribe to events.

== Endpoints

Endpoints are invoked to receive specific data from the blockchain application.
Endpoints are part of the request/response mechanism and are invoked via RPCs.

The following components can *expose* endpoints:

* xref:{url_intro_modules}[], for details about module specific endpoints, see xref:{url_module_endpoints}[Modules Overview].
* xref:{url_intro_plugins}[]
* and also the application itself, see xref:{url_advanced_rpc_endpoints}[application endpoints]

The following components can *invoke* endpoints:

* Plugins
* External services/applications

=== How to invoke endpoints

Whilst invoking an endpoint, the first argument is always the <<aliases,alias>>.
If input data is required, it is provided as a second argument. All endpoints can be invoked via either <<the-api-client>> or an HTTP request. The following example shows the invocation of an endpoint with and without additional arguments.

.How to invoke different kinds of endpoints with the API client
[source,js]
----
// How to invoke an endpoint.
const data = await client.invoke('system_getSchema');
console.log(data);

// How to invoke an endpoint that needs some data input.
const data = await client.invoke('namespace_endpointName', input); 
console.log(data);
----
// Example of how to invoke an action of the monitor plugin.
// client.invoke('network_getStats').then((val) => {
//     console.log(val);
// });
// <1> How to invoke an action.
// <2> How to invoke an action that needs some data input.
// <3> Example of how to invoke an action of the monitor plugin.
//--
// Channel::
// +
// --
// Actions can be invoked by plugins with the <<channel-for-plugins>>.

// .How to invoke an action inside a plugin
// [source,js]
// ----
// this._nodeInfo = await this.channel.invoke("app:getNodeInfo");
// ----
// --
//=====

== Events
By default, Lisk exposes various events that can be subscribed to get the latest information regarding network, chain, and transactions. These events can be subscribed to, by the following:

* xref:{url_intro_plugins}[]
* External services/applications

TIP: For more information about the default events exposed by the Lisk Framework, check out the xref:{url_RPC_Events}[Events reference] page.
// Events are part of the public publish / subscribe API of a blockchain application.
// If an event is published it is immediately received by all of the subscribers of the event.

// The following components can *publish* events:

// // * xref:{url_intro_modules}[]
// // * xref:{url_intro_plugins}[]
// * and also the application itself, see xref:{url_advanced_rpc_events}[application events]

// The following components can *subscribe* to events:


=== How to subscribe to events
Each event as described in the  xref:{url_RPC_Events}[Events reference] page can be subscribed to, by using the convention mentioned in the <<aliases>> section. The following snippet describes how an event can be subscribed by using <<the-api-client>>:

.Subscribing to an event
[source,typescript]
----
client.subscribe('network_newBlock', ( data ) => {
  console.log('new block: ',data);
});
----

