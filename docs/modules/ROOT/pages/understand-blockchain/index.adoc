= Key concepts of the Lisk blockchain
//Settings
:toc: preamble
:kv_footnote: pass:a,p[footnote:kv_footnote[]]
// URLs
:url_wiki_dfsm: https://en.wikipedia.org/wiki/Deterministic_finite_automaton
:url_blog_tree: https://lisk.com/blog/research/introducing-lisk-tree
:url_blog_merkle: https://lisk.com/blog/research/sparse-merkle-trees-and-new-state-model
// Project URLs
:url_intro_how_blockchain_works: intro/how-blockchain-works.adoc#state-machine

Learn the basics of blockchain applications, including how they are structured and which rules, terms and concepts are important to know when developing an own blockchain application with Lisk.

This section introduces the main concepts of the Lisk protocol.

== The three domains of a blockchain

At a very high level, there are three domains of a blockchain:

.The three domains of a blockchain application
image::understand-blockchain/3-domains.png[]

=== State machine

Every blockchain is at its core a replicated {url_wiki_dfsm}[deterministic finite-state machine^].

* A *state machine* is a concept in computer science, consisting of the following elements:
** *states:* A state machine typically has a set of different states, that it can enter.
For example, a padlock represented as state machine would have the two states "Open" and "Locked".
** *transitions:* a set of allowable operations that change from one state to another.
For example, to change from state "Open" to "Locked", a transition would be "Close padlock", and from "Locked" to "Open", it would be "Insert key & turn".
* *Replicated* describes the characteristic of blockchains to consist of a network of nodes all storing an individual copy of the blockchain, which replicates the state machine on each connected node.
* *Finite* means, the number of states, that the machine can reach is always finite.
* And *deterministic* means that if the state machine is replicated and all state transitions are replayed, it will end up always in the exact same state.

TIP: See also xref:{url_intro_how_blockchain_works}[Intro > How blockchain works > state machine].

In the blockchain context, these elements are represented as follows:

* A *state* is a state of the blockchain. In Lisk, a *key-value-store* is used as database, containing all data that is considered part of the blockchain.
* A *transition* of states is triggered through *blocks* and their containing *transactions* which are added to the blockchain.

==== The blockchain state as Sparse Merkle Tree

A Merkle tree is an authenticated data structure organized as a tree.
Let's try to understand what exactly each of these words mean:

* *Merkle:* This name is derived from the actual inventor of hash trees, Ralph Merkle.
* *data structure:* A data structure is a collection of data with a set of operations that can be performed on it.
An example of a data structure is an array, an object, or a Merkle tree.
* *authenticated:* The integrity of the data structure can be efficiently verified using the (Merkle) root of the tree.
The dataset cannot be altered without changing the Merkle root.
* *tree:* The underlying data structure is organized as a tree, where each parent node is obtained by hashing the data from the child nodes in the layer below.
Here we consider only *binary trees*, where each parent has two children.

A *sparse Merkle tree (SMT)* is very similar to a regular Merkle Tree, with the following difference:
The order of insertion of data blocks does not matter, and the root of the tree only depends on the final state of the map.
That means, in an SMT, the input of the hash function is the underlying <<kv-maps, key-value map>> and the output is the Merkle root.
Due to the history independence, SMTs are the suitable choice to authenticate key-value maps.

.RMT vs SMT
image::understand-blockchain/rmt-vs-smt.png[]

.SMTs allow efficient (non-)inclusion proofs
[NOTE]
A Prover is able to convince a Verifier that a certain element is present in the underlying data structure **without revealing any other element**, and the *proof size scales logarithmically* with the number of data blocks.
A Prover can convince a Verifier that a certain entry is not present in the map, and the proof size scales logarithmically with the number of data blocks.

We create an SMT on top of the state store, called the **state tree**.
Then we insert the Merkle root of this tree, the state root, into each block header.

A blockchain created with the Lisk SDK defines a single global store. Each module registered in the chain defines its own generic key-value map, whereby each element is identified by the following properties:

* **Module ID**: The ID of the module, identifying the key-value map. We will reserve all module IDs starting with a 0 in their binary representation to modules that are shipped with the SDK by default. The IDs of modules developed as part of each blockchain application will start with a 1. The module ID has a fixed length of 4 bytes.
* **Store prefix**: Each module can define several buckets, to separate different data structures within the store. Each bucket is identified by the store prefix. The store prefix has a fixed length of 2 bytes.
* **Store key**: The store key identifies a certain element within a store bucket.
* **JSON schema**: The schema used in Lisk codec to serialize the value

image::understand-blockchain/smt.png[]

==== Use cases of SMTs

SMTs provides several benefits:

* **Interoperability**: The state root is used during the processing of cross-chain update transactions to authenticate the outgoing messages from one chain.
* **State consistency**: All nodes in the network will be able to check the consistency of the state just by checking the state root.
For instance, if a block contains a transaction that randomly credits either a user A or a user B with tokens, then any node obtaining a different result from the block forger would immediately reject the block, as the two state roots would differ.
* **Light clients**: The state root can be used to provide efficient proofs for the state of a certain account.

==== Use cases of RMTs

RMTs provides several benefits:

* **Proofs-of-Inclusion for Transactions in a Block**:
Each block header stores the `transactionRoot`.
The `transactionRoot` is calculated as the Merkle root of the IDs of the transactions included in the block payload (the details are specified in LIP 0032).
Using the `transactionRoot` and a proof-of-inclusion, it is be possible to check whether a certain transaction is part of the block without downloading the full block.
* **Decentralized Regenesis**:
A snapshot of the blockchain can be used to perform a hardfork to implement the new protocol.
Reference to the last blockchain state will be stored as the Merkle root of the hashes of all blocks up to the snapshot.

[[kv-maps]]
****
What are key-value maps?

A key-value map is a collection of (key, value) pairs such that each key appears at most once.
It supports the following operations:

* Look up: Returns the value associated with a certain key.
* Insert: Inserts a certain key-value pair in the collection.
* Update: Updates the value associated with a certain key.
* Delete: Removes a certain key-value pair in the collection.
****

[TIP]
====
For more information about RMTs and SMTs, check out the following blog posts:

* {url_blog_tree}[^]
* {url_blog_merkle}[^]
====

=== Consensus

=== Network

The state tree is the sparse Merkle tree built on top of the state store.
Organizing the state of a blockchain in a Merkle tree allows to cryptographically authenticate the whole state with a single hash, the state root.
The state root property is calculated at the end of the block processing as the Merkle root of the state tree and included in the block header.
Information from the block header is then used to create a certificate and signed by the chain validators.


////
TODO: Explain the structure of the state is structured as a Sparse Merkel Tree
TODO: Explain what is a Sparse Merkel Tree, and its benefits for blockchain
TODO: Include image of a Sparse Merkel Tree of a blockchain app
////

== Blocks

//TODO: Include image of the anatomy of a block

=== Block generation

=== Block processing

=== Block schema

=== Block validation

=== Block header

=== Block transactions

=== Block assets

=== Block Signature Calculation

== Transactions

//TODO: Include image of the anatomy of a transaction

=== Transaction schema

=== Transaction header