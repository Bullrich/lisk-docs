= Key concepts of the Lisk blockchain
//Settings
:toc: preamble
:fn_tree: footnote:tree[See xref:{url_protocol_blocks}[] page of the Lisk protocol.]
// Project URLs
:url_intro_how_blockchain_works: intro/how-blockchain-works.adoc#state-machine
:url_intro_consensus: intro/how-blockchain-works.adoc#consensus-mechanisms
:url_understand_state_machine: understand-blockchain/state-machine.adoc
:url_understand_state_machine_tree: understand-blockchain/state-machine.adoc#the-blockchain-state-as-sparse-merkle-tree

Learn the basics of blockchain applications, including how they are structured and which rules, terms and concepts are important to know when developing an own blockchain application with Lisk.

This section introduces the main concepts of the Lisk protocol.

== The three domains of a blockchain

At a very high level, there are three domains of a blockchain:

.The three domains of a blockchain application
image::understand-blockchain/3-domains.png["3 domains of blockchain", 300, align="center"]

. xref:{url_understand_state_machine}[State machine domain]: Responsible for transitioning the blockchain state with deterministic logic.
. xref:{url_understand_state_machine}[Consensus domain]: Responsible for the replication of the same sequence of states among all nodes in the network.
This is achieved by nodes in the network following a xref:{url_intro_consensus}[consensus protocol] and utilizing the state machine and network domains.
. xref:{url_understand_state_machine}[Network domain]:: Responsible for the communication of the peer-to-peer network.

== Blocks

.Anatomy of a block
image::understand-blockchain/block.png["Anatomy of a Lisk block",300,align="center"]

=== Block header

Properties handled by the xref:{url_understand_state_machine}[consensus] domain are added to the block header.

The block header consists of the following properties:

* `generatorAddress`: The address of the block generator.
It replaces the `generatorPublicKey` property.
See below for more details.
* `assetRoot`: The root of the Merkle tree computed from the block assets array.
See below for more details.
* `eventRoot`: The root of the sparse Merkle tree that is computed from the events emitted during the block processing.
See LIP "Introduce events and event root" LIP for the reason why it needs to be included in a block header.
* `stateRoot`: The root of the sparse Merkle tree that is computed from the state of the blockchain.
See LIP 0040 for the reason why it needs to be included in a block header.
* `maxHeightPrevoted`: This property is related to the Lisk-BFT protocol and is used for the fork choice rule.
* `maxHeightGenerated`: This property is related to the Lisk-BFT protocol and is used to check for contradicting block headers.
* `validatorsHash`: This property authenticates the set of validators active from the next block onward.
It is important for cross-chain certification and included in certificates.
* `aggregateCommit`: This property contains the aggregate signature for a certificate and the height of the certified block.
Based on this, any node can create a certificate for the given height.
See LIP 0061 for more details.


=== Block assets

Properties created by individual modules are added to the block assets.

As an example, blockchains created with the Lisk SDK that implement the Random module, will insert the seed reveal property in the block assets, not in the block header.

The schema for the block assets allows each module to include its serialized data individually, which makes the inclusion of module data very flexible.
Each module can insert a single entry in the assets.
This entry is an object containing a `moduleID` property, indicating the ID of the module handling it, and a generic data property that can contain arbitrary serialized data.

Each entry of the block assets is then inserted in a Merkle tree {fn_tree}, whose root is included in the block header as the `assetRoot` property.
Inserting the assets root rather than the full assets allows to bound the size of the block header while still authenticating the content of the block assets.

=== Block transactions

=== Block generation

image::understand-blockchain/block-generation.png["Block generation steps",300, align="center"]

The full generation of a block is organized as follows.

. **Header initialization**: Block header properties that require access to the state store before any state transitions implied by the block are executed are inserted in this stage.
. **Assets insertion**: Each module can insert information in the block assets.
. **Before transactions execution**: Each module can define protocol logic that is executed before the transactions contained in the block are processed.
After this stage has been completed, transactions are selected one-by-one from a transaction pool.
The transaction processing stages (stages 4 to 8) are repeated for each transaction selected.
If stages 4, 5, 6, and 8 are executed successfully, the transaction is valid and it is included in the block, otherwise it is invalid and therefore discarded.
. **Transaction verification**: Each module can define protocol logic that verifies a transaction, possibly by accessing the state store.
If an error occurs, the transaction is invalid and it is not included in the block.
. **Command verification**: The command corresponding to the `moduleID`-`commandID` combination is verified.
If an error occurs, the transaction is invalid and it is not included in the block.
. **Before command execution**: Each module can define protocol logic that is processed before the command has been executed.
If an error occurs, the transaction is invalid, it is not included in the block, all state transitions induced by the transaction are reverted.
In that case, the block generation continues with stage 4 for another transaction from the transaction pool or stage 9.
. **Command execution**: The command corresponding to the `moduleID`-`commandID` combination is executed.
If an error occurs, the transaction is failed and all state transitions performed in this stage are reverted.
In any case, afterwards the processing continues with the next stage.
. **After command execution**: Each module can define protocol logic that is processed after the command has been executed.
If an error occurs, the transaction is invalid, it is not included in the block and all state transitions induced by the transaction performed up to this stage are reverted.
In that case, the block generation continues with stage 4 for another transaction from the transaction pool or stage 9.
. **After transactions execution**: Each module can define protocol logic that is executed after all the transactions contained in the block have been processed.
. **Header finalization**: Block header properties, which require accessing the state store after all state transitions implied by the block have been executed, are inserted.
. **Block processing**: The block goes through the <<block-processing>> stages.

=== Block processing

image::understand-blockchain/block-processing.png["Block prosessing steps",500, align="center"]

The full processing of a block is organized as follows.

. **Block reception**: A new block is received from the P2P network.
. **Fork choice**: Upon receiving a new block, the fork choice rule determines whether the block will be discarded or if the processing continues.
. **Static validation**: Some initial static checks are done to ensure that the serialized object follows the general structure of a block.
These checks are performed immediately because they do not require access to the state store and can therefore be done very quickly.
. **Header verification**: Block header properties that require access to the state store before any state transitions implied by the block are executed are verified in this stage.
. **Assets verification**: Each module verifies the respective entry in the block assets.
If any check fails, the block is discarded and has no further effect.
. **Block forwarding**: After the initial checks, the full block is forwarded to a subset of peers.
. **Before transactions execution**: Each module can define protocol logic that is executed before the transactions contained in the block are processed.
. **Transaction verification**: Each module can define protocol logic that verifies a transaction, possibly by accessing the state store.
If an error occurs, the transaction is invalid and the whole block is discarded.
. **Command verification**: The command corresponding to the moduleID-commandID combination is verified.
If an error occurs, the transaction is invalid and the whole block is discarded.
. **Before command execution**: Each module can define protocol logic that is processed before the command has been executed.
If an error occurs, the transaction is invalid and the whole block is discarded.
. **Command execution**: The command corresponding to the moduleID-commandID combination is executed.
If an error occurs, the transaction is failed and all state transitions performed in this stage are reverted.
In any case, afterwards the processing continues with the next stage.
. **After command execution**: Each module can define protocol logic that is processed after the command has been executed.
If an error occurs, the transaction is invalid and the whole block is discarded.
. **After transactions execution**: Each module can define protocol logic that is executed after all the transactions contained in the block have been processed.
. **Result verification**: Block header properties, which require accessing the state store after all state transitions implied by the block have been executed, are verified.
. **Block storage**: The block is persisted into the database.
. **Peers notification**: Other peers in the P2P network are notified of the new block.

=== Block schema

=== Block validation

=== Block Signature Calculation

== Transactions

//TODO: Include image of the anatomy of a transaction

A transaction is valid, if the "transaction verification", "command verification", "before command execution", and "after command execution" stages associated to the transaction are executed successfully without errors (see the "Block processing stages" section below).
Otherwise, a transaction is invalid.
Only valid transactions should be added to a block during the block generation, as an invalid transaction makes the whole block invalid meaning that it would be discarded by any node in the network.

A valid transaction is executed successfully if additionally the "command execution" stage is executed successfully without errors.
A valid transaction fails if on the other hand an error occurs during the command execution.
In this case, all state transitions of the "command execution" stage are reverted.
This means that the transaction has no effect except for those defined in "before command execution" and "after command execution".
The result of the transaction execution is logged using an event emitted at the end of the "after transaction execution" stage, indicating whether the transaction was processed successfully or an error occurred.

=== Transaction schema

=== Transaction header